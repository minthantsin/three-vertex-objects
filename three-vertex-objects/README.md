# three-vertex-objects

![creative-coding](https://img.shields.io/badge/creative-coding-blue) ![game-dev](https://img.shields.io/badge/game-dev-red)

is a typescript library that allows you to create and render multiple and (optionally) instanced geometries with just a single draw call.
such _vertex objects_ are defined by a descriptor &mdash; for creation and usage there is a super easy and satisfying to use object-based api.

it's based on the fantastic [three.js](https://threejs.org/) library which itself is build upon _WebGL_.

the main features of this library are centered around the definition, creation and life-cycle management of _vertex objects_,
in addition there are some more helpers and classes to ease the texture handling, respectively the loading of texture-atlas definitions.

## Vertex Objects

are like particles or freestyle [sprites](https://en.wikipedia.org/wiki/Sprite_(computer_graphics)) whose attributes, vertex and fragment shaders are completely freely definable &mdash; but the management and organization of the underlying geometry data attribute arrays is taken away from you

examples can be found here:
- [animated-billboards](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/animated-billboards.html)
- [animated-sprites](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/animated-sprites.html) &mdash; [vertex object descriptor](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/jsm/animated-sprites/)
- [instanced-quads](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/instanced-quads.html)
- [crosses](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/crosses.html)
- [textured-quads-from-tileset](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/textured-quads-from-tileset.html)
- [textured-quads](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/textured-quads.html)
- [textured-sprites](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/textured-sprites.html) &mdash; [vertex object descriptor](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/jsm/textured-sprites/)


## Texture Mapping

those who work with sprites will quickly realize that an easy way to import [spritesheet images and texture-atlas definitions](https://en.wikipedia.org/wiki/Texture_atlas) could be very handy.
this library provides helpers for importing tilesets via grid-aligned spritesheet images or texture altases from json files (generated by tools such as [TexturePacker](https://www.codeandweb.com/texturepacker)).

examples can be found here:
- [animated-billboards](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/animated-billboards.html)
- [animated-sprites](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/animated-sprites.html)
- [textured-quads-from-tileset](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/textured-quads-from-tileset.html)
- [textured-sprites](https://github.com/spearwolf/three-vertex-objects/tree/master/examples/textured-sprites.html)


## CHEAT SHEET: Vertex Object Descriptors

### Define

```js
{
    vertexCount: 4,
    indices: [0, 1, 2, 0, 2, 3],        // [optional]

    meshCount: 1,                       // for instanced attributes (use instead of vertexCount)
                                        // not yet fully thought through: VertexBufferObject <- capacity <- meshCount > 1 ?
    attributes: {
        position: {                                     // attribute name
            components: ['x', 'y', 'z'],                // either define components ..
            size: 3,                                    // .. or set number of anonymous components

            type: 'float32',                            // [optional] the default type is float32
            normalized: boolean,                        // [optional] default is not

            usage: 'static' | 'dynamic' | 'stream',     // [optional] default is 'static'
            autoTouch: true                             // [optional] if usage == 'static' then default is false otherwise true
         }
    }

    prototpe: MyBaseClass.prototype;  // [optional]

    methods: {  // TODO not yet implemented
        [methodName]() {}
    }
}
```

### API

```js
const geometry = new VertexObjectGeometry(descriptor, CAPACITY = 1);

const geometry = new InstancedVertexObjectGeometry(instancedDescriptor, INSTANCED_CAPACITY, baseDescriptor, BASE_CAPACITY = 1);
const geometry = new InstancedVertexObjectGeometry(instancedDescriptor, INSTANCED_CAPACITY, baseBufferGeometry);

const vo = geometry.pool.createVO()  // VertexObjectGeometry

const vo = geometry.basePool.createVO()       // InstancedVertexObjectGeometry
const vo = geometry.instancedPool.createVO()

vo.setPosition([...])
vo.x0_0
vo.x1_0
vo.x3_0
vo.x0_1

vo.copy(vo)

geometry.pool.freeVO(vo)
geometry.basePool.freeVO(vo)
geometry.instancedPool.freeVO(vo)

geometry.touchAttributes('position', 'foo')
geometry.touchBuffers({dynamic: false, stream: true, static: false})
geometry.touch('position', {dynamic: true}, ...)  // yes, you can mix it here if you want

geometry.update()  // automatically called by VertexObjects
```

### Usage

```js
const mesh = new VertexObjects(geometry, material)

mesh.frustumCalled = false  // can be very helpful in the development ;)

scene.add(mesh)
```
