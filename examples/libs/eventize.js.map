{"version":3,"file":"eventize.js.map","sources":["../src/Priority.ts","../src/constants.ts","../src/utils.ts","../src/EventKeeper.ts","../src/EventListener.ts","../src/EventStore.ts","../src/isEventized.ts","../src/subscribeTo.ts","../src/injectEventizeApi.ts","../src/eventize.ts"],"sourcesContent":["import {EventizePriority} from './types';\n\nexport const Priority: EventizePriority = {\n  Max: Number.POSITIVE_INFINITY,\n  AAA: 1000000000,\n  BB: 1000000,\n  C: 1000,\n  Default: 0,\n  Low: -10000,\n  Min: Number.NEGATIVE_INFINITY,\n};\n","export const EVENT_CATCH_EM_ALL = '*';\n\nexport const LISTENER_UNKNOWN = 0;\nexport const LISTENER_IS_FUNC = 1;\nexport const LISTENER_IS_NAMED_FUNC = 2;\nexport const LISTENER_IS_OBJ = 4;\n\nexport const NAMESPACE: symbol = (() => {\n  // @ts-ignore\n  if (!Symbol.eventize) {\n    // @ts-ignore\n    Symbol.eventize = Symbol('eventize');\n  }\n  // @ts-ignore\n  return Symbol.eventize;\n})();\n\nexport const LOG_NAMESPACE = '[eventize]';\n","/* eslint-disable no-console */\nimport {LOG_NAMESPACE, EVENT_CATCH_EM_ALL} from './constants';\nimport {EventName} from './types';\n\nexport const isCatchEmAll = (eventName: unknown): eventName is string =>\n  eventName === EVENT_CATCH_EM_ALL;\n\nexport const isEventName = (eventName: unknown): eventName is EventName => {\n  switch (typeof eventName) {\n    case 'string':\n    case 'symbol':\n      return true;\n    default:\n      return false;\n  }\n};\n\nexport const hasConsole = typeof console !== 'undefined';\n\nexport const warn = hasConsole\n  ? console[console.warn ? 'warn' : 'log'].bind(console, LOG_NAMESPACE)\n  : () => {};\n\ntype PropertyKey = string | symbol;\ntype PropertyValue = any;\n\nexport const definePublicPropertyRO = <T extends Object>(\n  obj: T,\n  name: PropertyKey,\n  value: PropertyValue,\n): T => {\n  Object.defineProperty(obj, name, {\n    value,\n    configurable: true,\n    enumerable: true,\n  });\n  return obj;\n};\n\nexport const definePublicPropertiesRO = <T extends Object>(\n  obj: T,\n  attrs: Record<PropertyKey, PropertyValue>,\n): T => {\n  const keys = Object.keys(attrs);\n  const len = keys.length;\n  for (let i = 0; i < len; i += 1) {\n    definePublicPropertyRO(obj, keys[i], attrs[keys[i]]);\n  }\n  return obj;\n};\n\nexport const defineHiddenPropertyRO = <T extends Object>(\n  obj: T,\n  name: PropertyKey,\n  value: PropertyValue,\n): T => {\n  Object.defineProperty(obj, name, {\n    value,\n    configurable: true,\n  });\n  return obj;\n};\n","import {AnyEventNames, EventArgs, EventName} from './types';\nimport {isCatchEmAll} from './utils';\n\nexport class EventKeeper {\n  events = new Map<EventName, EventArgs>();\n  eventNames = new Set<EventName>();\n\n  add(eventNames: AnyEventNames): void {\n    if (Array.isArray(eventNames)) {\n      eventNames.forEach((name) => this.eventNames.add(name));\n    } else {\n      this.eventNames.add(eventNames);\n    }\n  }\n\n  remove(eventNames: AnyEventNames): void {\n    if (Array.isArray(eventNames)) {\n      eventNames.forEach((name) => this.eventNames.delete(name));\n    } else {\n      this.eventNames.delete(eventNames);\n    }\n  }\n\n  retain(eventName: EventName, args: EventArgs): void {\n    if (this.eventNames.has(eventName)) {\n      this.events.set(eventName, args);\n    }\n  }\n\n  isKnown(eventName: EventName): boolean {\n    return this.eventNames.has(eventName);\n  }\n\n  emit(\n    eventName: EventName,\n    eventListener: {apply: (eventName: EventName, args?: EventArgs) => void},\n  ): void {\n    if (!isCatchEmAll(eventName)) {\n      const args = this.events.get(eventName);\n      if (args) {\n        eventListener.apply(eventName, args);\n      }\n    } else {\n      this.eventNames.forEach((name) => this.emit(name, eventListener));\n    }\n  }\n}\n","import {\n  EVENT_CATCH_EM_ALL,\n  LISTENER_IS_FUNC,\n  LISTENER_IS_NAMED_FUNC,\n  LISTENER_IS_OBJ,\n} from './constants';\n\nimport {EventName, EventArgs, ListenerObjectType} from './types';\nimport {isCatchEmAll} from './utils';\n\ntype EmitFnType = Function | undefined;\ntype CallAfterApplyFnType = (() => void) | undefined;\n\nconst apply = (context: unknown, func: EmitFnType, args: EventArgs) => {\n  if (typeof func === 'function') {\n    func.apply(context, args);\n  }\n};\n\nconst emit = (\n  eventName: EventName,\n  listener: {emit: EmitFnType},\n  args: EventArgs,\n) => apply(listener, listener.emit, [eventName].concat(args));\n\nconst detectListenerType = (listener: unknown) => {\n  switch (typeof listener) {\n    case 'function':\n      return LISTENER_IS_FUNC;\n    case 'string':\n    case 'symbol':\n      return LISTENER_IS_NAMED_FUNC;\n    case 'object':\n      return LISTENER_IS_OBJ;\n  }\n};\n\nlet lastId = 0;\nconst createUniqId = () => ++lastId;\n\nexport class EventListener {\n  readonly id: number;\n  readonly eventName: EventName;\n  readonly isCatchEmAll: boolean;\n  readonly priority: number | undefined;\n  readonly listener: unknown;\n  readonly listenerObject: ListenerObjectType;\n  readonly listenerType: number;\n  callAfterApply: CallAfterApplyFnType;\n  isRemoved: boolean;\n\n  constructor(\n    eventName: EventName,\n    priority: number | undefined,\n    listener: unknown,\n    listenerObject: ListenerObjectType = null,\n  ) {\n    this.id = createUniqId();\n    this.eventName = eventName;\n    this.isCatchEmAll = isCatchEmAll(eventName);\n    this.listener = listener;\n    this.listenerObject = listenerObject;\n    this.priority = priority;\n    this.listenerType = detectListenerType(listener);\n    this.callAfterApply = undefined;\n    this.isRemoved = false;\n  }\n\n  isEqual(\n    listener: unknown,\n    listenerObject: ListenerObjectType = null,\n  ): boolean {\n    if (listener === this) return true;\n    const typeofListener = typeof listener;\n    if (typeofListener === 'number' && listener === this.id) return true;\n    if (\n      listenerObject === null &&\n      (typeofListener === 'string' || typeofListener === 'symbol')\n    ) {\n      if (listener === EVENT_CATCH_EM_ALL) return true;\n      if (listener === this.eventName) return true;\n      return false;\n    }\n    return this.listener === listener && this.listenerObject === listenerObject;\n  }\n\n  apply(eventName: EventName, args?: EventArgs): void {\n    if (this.isRemoved) return;\n\n    const {listener, listenerObject} = this;\n\n    switch (this.listenerType) {\n      case LISTENER_IS_FUNC:\n        // @ts-ignore\n        apply(listenerObject, listener, args);\n        if (this.callAfterApply) this.callAfterApply();\n        break;\n\n      case LISTENER_IS_NAMED_FUNC:\n        // @ts-ignore\n        apply(listenerObject, listenerObject[listener], args);\n        if (this.callAfterApply) this.callAfterApply();\n        break;\n\n      case LISTENER_IS_OBJ: {\n        // @ts-ignore\n        const func = listener[eventName];\n        if (this.isCatchEmAll || this.eventName === eventName) {\n          if (typeof func === 'function') {\n            func.apply(listener, args);\n          } else {\n            // @ts-ignore\n            emit(eventName, listener, args);\n          }\n          if (this.callAfterApply) this.callAfterApply();\n        }\n        break;\n      }\n    }\n  }\n}\n","import {EventListener} from './EventListener';\nimport {EVENT_CATCH_EM_ALL} from './constants';\nimport {EventName, ListenerObjectType} from './types';\nimport {isCatchEmAll, isEventName} from './utils';\n\ntype HasPriorityOrIdType = {priority: number; id: number};\n\nconst sortByPrioAndId = (\n  a: HasPriorityOrIdType,\n  b: HasPriorityOrIdType,\n): number =>\n  a.priority !== b.priority ? b.priority - a.priority : a.id - b.id;\n\nconst cloneArray = <T>(arr: Array<T>): Array<T> => arr?.slice(0);\n\nconst removeListenerItem = (arr: Array<any>, listener: any) => {\n  const idx = arr.indexOf(listener);\n  if (idx > -1) {\n    arr.splice(idx, 1);\n  }\n};\n\nconst removeListener = (\n  listeners: Array<EventListener>,\n  listener: unknown,\n  listenerObject: ListenerObjectType,\n) => {\n  const idx = listeners.findIndex((item) =>\n    item.isEqual(listener, listenerObject),\n  );\n  if (idx > -1) {\n    listeners[idx].isRemoved = true;\n    listeners.splice(idx, 1);\n  }\n};\n\nconst removeAllListeners = (listeners: Array<EventListener>) => {\n  if (listeners) {\n    listeners.forEach((li) => {\n      li.isRemoved = true;\n    });\n    listeners.length = 0;\n  }\n};\n\nexport class EventStore {\n  readonly namedListeners: Map<EventName, Array<EventListener>>;\n  readonly catchEmAllListeners: Array<EventListener>;\n\n  constructor() {\n    this.namedListeners = new Map();\n    this.catchEmAllListeners = [];\n  }\n\n  add(eventListener: EventListener): void {\n    if (eventListener.isCatchEmAll) {\n      this.catchEmAllListeners.push(eventListener);\n      this.catchEmAllListeners.sort(sortByPrioAndId);\n    } else {\n      const {eventName} = eventListener;\n      let namedListeners = this.namedListeners.get(eventName);\n      if (!namedListeners) {\n        namedListeners = [];\n        this.namedListeners.set(eventName, namedListeners);\n      }\n      namedListeners.push(eventListener);\n      namedListeners.sort(sortByPrioAndId);\n    }\n  }\n\n  remove(listener: unknown, listenerObject: ListenerObjectType): void {\n    if (listenerObject == null && Array.isArray(listener)) {\n      listener.forEach(this.remove.bind(this));\n    } else if (\n      listener == null ||\n      (listenerObject == null && isCatchEmAll(listener))\n    ) {\n      this.removeAllListeners();\n    } else if (listenerObject == null && isEventName(listener)) {\n      const listeners = this.namedListeners.get(listener);\n      removeAllListeners(listeners);\n    } else if (listener instanceof EventListener) {\n      listener.isRemoved = true;\n      this.namedListeners.forEach((namedListeners) =>\n        removeListenerItem(namedListeners, listener),\n      );\n      removeListenerItem(this.catchEmAllListeners, listener);\n    } else {\n      this.namedListeners.forEach((namedListeners) =>\n        removeListener(namedListeners, listener, listenerObject),\n      );\n      removeListener(this.catchEmAllListeners, listener, listenerObject);\n    }\n  }\n\n  removeAllListeners(): void {\n    this.namedListeners.forEach((namedListeners) =>\n      removeAllListeners(namedListeners),\n    );\n    this.namedListeners.clear();\n    removeAllListeners(this.catchEmAllListeners);\n  }\n\n  forEach(eventName: EventName, fn: (listener: EventListener) => void): void {\n    const catchEmAllListeners = cloneArray(this.catchEmAllListeners);\n    const namedListeners = cloneArray(this.namedListeners.get(eventName));\n    if (\n      eventName === EVENT_CATCH_EM_ALL ||\n      !namedListeners ||\n      namedListeners.length === 0\n    ) {\n      catchEmAllListeners.forEach(fn);\n    } else if (catchEmAllListeners.length === 0) {\n      namedListeners.forEach(fn);\n    } else {\n      const iLen = namedListeners.length;\n      const jLen = catchEmAllListeners.length;\n      let i = 0;\n      let j = 0;\n      while (i < iLen || j < jLen) {\n        if (i < iLen) {\n          const cur = namedListeners[i];\n          if (j >= jLen || cur.priority >= catchEmAllListeners[j].priority) {\n            fn(cur);\n            ++i;\n            continue;\n          }\n        }\n        if (j < jLen) {\n          fn(catchEmAllListeners[j]);\n          ++j;\n        }\n      }\n    }\n  }\n}\n","import {NAMESPACE} from './constants';\nimport {EventizeApi, EventizeGuard} from './types';\n\nexport const isEventized: EventizeGuard = <T extends Object>(\n  obj: T,\n): obj is T & EventizeApi =>\n  Boolean(\n    obj &&\n      // @ts-ignore\n      obj[NAMESPACE],\n  );\n","import {EventKeeper} from './EventKeeper';\nimport {EventListener} from './EventListener';\nimport {EventStore} from './EventStore';\nimport {Priority} from './Priority';\nimport {EVENT_CATCH_EM_ALL} from './constants';\nimport {EventArgs, EventName, ListenerObjectType} from './types';\nimport {hasConsole, warn} from './utils';\n\nconst registerEventListener = (\n  store: EventStore,\n  keeper: EventKeeper,\n  eventName: EventName,\n  priority: number,\n  listener: unknown,\n  listenerObject: ListenerObjectType,\n): EventListener => {\n  const eventListener = new EventListener(\n    eventName,\n    priority,\n    listener,\n    listenerObject,\n  );\n  store.add(eventListener);\n  keeper.emit(eventName, eventListener);\n  return eventListener;\n};\n\nexport const subscribeTo = (\n  store: EventStore,\n  keeper: EventKeeper,\n  args: EventArgs,\n): EventListener | Array<EventListener> => {\n  const len = args.length;\n  const typeOfFirstArg = typeof args[0];\n\n  let eventName: EventName;\n  let priority: number;\n  let listener: unknown;\n  let listenerObject: ListenerObjectType;\n\n  if (len >= 2 && len <= 3 && typeOfFirstArg === 'number') {\n    eventName = EVENT_CATCH_EM_ALL;\n    [priority, listener, listenerObject] = args;\n  } else if (len >= 3 && len <= 4 && typeof args[1] === 'number') {\n    [eventName, priority, listener, listenerObject] = args;\n  } else {\n    priority = Priority.Default;\n    if (\n      typeOfFirstArg === 'string' ||\n      typeOfFirstArg === 'symbol' ||\n      Array.isArray(args[0])\n    ) {\n      [eventName, listener, listenerObject] = args;\n    } else {\n      eventName = EVENT_CATCH_EM_ALL;\n      [listener, listenerObject] = args;\n    }\n  }\n\n  if (!listener && hasConsole) {\n    warn('called with insufficient arguments!', args);\n    throw 'subscribeTo called with insufficient arguments!';\n  }\n\n  const register = (prio: number) => (event: EventName) =>\n    registerEventListener(store, keeper, event, prio, listener, listenerObject);\n\n  if (Array.isArray(eventName)) {\n    return eventName.map((name) => {\n      if (Array.isArray(name)) {\n        return register(name[1])(name[0]);\n      }\n      return register(priority)(name);\n    });\n  }\n  return register(priority)(eventName);\n};\n","import {EventKeeper} from './EventKeeper';\nimport {EventListener} from './EventListener';\nimport {EventStore} from './EventStore';\nimport {EVENT_CATCH_EM_ALL, NAMESPACE} from './constants';\nimport {isEventized} from './isEventized';\nimport {subscribeTo} from './subscribeTo';\nimport {\n  AnyEventNames,\n  EventArgs,\n  EventizeApi,\n  EventName,\n  ListenerType,\n  ListenerObjectType,\n  SubscribeArgs,\n  UnsubscribeFunc,\n} from './types';\nimport {defineHiddenPropertyRO, isEventName} from './utils';\n\nconst unsubscribeAfterApply = (obj: EventizeApi) => (\n  listener: EventListener,\n) => {\n  listener.callAfterApply = () => obj.off(listener);\n};\n\nconst makeUnsubscribe = (\n  host: EventizeApi,\n  listeners: EventListener | Array<EventListener>,\n): UnsubscribeFunc => {\n  const unsubscribe = () => host.off(listeners);\n  return Object.assign(\n    unsubscribe,\n    Array.isArray(listeners) ? {listeners} : {listener: listeners},\n  ) as UnsubscribeFunc;\n};\n\nexport function injectEventizeApi<T extends Object>(obj: T): T & EventizeApi {\n  if (isEventized(obj)) {\n    // it already has the interface - no need to inject it again\n    return obj;\n  }\n\n  const store = new EventStore();\n  const keeper = new EventKeeper();\n\n  defineHiddenPropertyRO(obj, NAMESPACE, {keeper, store});\n\n  const eventizedObj = Object.assign(obj, {\n    on(...args: SubscribeArgs): UnsubscribeFunc {\n      return makeUnsubscribe(eventizedObj, subscribeTo(store, keeper, args));\n    },\n\n    once(...args: SubscribeArgs): UnsubscribeFunc {\n      const listeners = subscribeTo(store, keeper, args);\n      if (Array.isArray(listeners)) {\n        listeners.forEach(unsubscribeAfterApply(eventizedObj));\n      } else {\n        unsubscribeAfterApply(eventizedObj)(listeners);\n      }\n      return makeUnsubscribe(eventizedObj, listeners);\n    },\n\n    off(listener?: ListenerType, listenerObject?: ListenerObjectType): void {\n      store.remove(listener, listenerObject);\n      if (Array.isArray(listener)) {\n        keeper.remove(listener.filter((li) => typeof li === 'string'));\n      } else if (isEventName(listener)) {\n        keeper.remove(listener);\n      }\n    },\n\n    emit(eventNames: AnyEventNames, ...args: EventArgs): void {\n      if (Array.isArray(eventNames)) {\n        eventNames.forEach((event: EventName) => {\n          store.forEach(event, (listener) => listener.apply(event, args));\n          keeper.retain(event, args);\n        });\n      } else if (eventNames !== EVENT_CATCH_EM_ALL) {\n        store.forEach(eventNames, (listener) => {\n          listener.apply(eventNames, args);\n        });\n        keeper.retain(eventNames, args);\n      }\n    },\n\n    retain(eventName: EventName): void {\n      keeper.add(eventName);\n    },\n  });\n\n  return eventizedObj;\n}\n","import {Priority} from './Priority';\nimport {EVENT_CATCH_EM_ALL} from './constants';\nimport {injectEventizeApi} from './injectEventizeApi';\nimport {isEventized} from './isEventized';\nimport {EventizeApi, EventizeFuncApi} from './types';\n\nexport const eventize: EventizeFuncApi = (() => {\n  const api = <T extends Object>(obj: T): T & EventizeApi =>\n    injectEventizeApi(obj);\n\n  api.inject = injectEventizeApi;\n\n  api.extend = <T extends Object>(obj: T): T & EventizeApi =>\n    injectEventizeApi(Object.create(obj));\n\n  api.create = (obj: Object): EventizeApi => {\n    const eventizer = injectEventizeApi({});\n    eventizer.on(EVENT_CATCH_EM_ALL, Priority.Default, obj);\n    return eventizer;\n  };\n\n  api.is = isEventized;\n  api.Priority = Priority;\n\n  return api;\n})();\n\nexport interface Eventize extends EventizeApi {}\n\nexport class Eventize {\n  constructor() {\n    eventize(this);\n  }\n}\n"],"names":["Priority","Max","Number","POSITIVE_INFINITY","AAA","BB","C","Default","Low","Min","NEGATIVE_INFINITY","NAMESPACE","Symbol","eventize","isCatchEmAll","eventName","isEventName","hasConsole","console","warn","bind","EventKeeper","[object Object]","this","Map","Set","eventNames","Array","isArray","forEach","name","add","delete","args","has","events","set","eventListener","emit","get","apply","context","func","lastId","EventListener","priority","listener","listenerObject","id","listenerType","detectListenerType","callAfterApply","undefined","isRemoved","typeofListener","concat","sortByPrioAndId","a","b","cloneArray","arr","slice","removeListenerItem","idx","indexOf","splice","removeListener","listeners","findIndex","item","isEqual","removeAllListeners","li","length","EventStore","namedListeners","catchEmAllListeners","push","sort","remove","clear","fn","iLen","jLen","i","j","cur","isEventized","obj","Boolean","subscribeTo","store","keeper","len","typeOfFirstArg","register","prio","event","registerEventListener","map","unsubscribeAfterApply","off","makeUnsubscribe","host","Object","assign","injectEventizeApi","value","defineProperty","configurable","defineHiddenPropertyRO","eventizedObj","on","filter","retain","api","inject","extend","create","eventizer","is","Eventize"],"mappings":"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"}